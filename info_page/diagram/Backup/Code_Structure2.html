<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Analysis Workflow - Border Arrows</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #f0f2f5; /* Slightly different light background */
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
        }
        .main-app-container {
            width: 98%;
            max-width: 1600px; /* Wider for more complex layout */
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px; /* Softer radius */
            box-shadow: 0 8px 25px rgba(0,0,0,0.08); /* Softer shadow */
            overflow: hidden; 
        }
        h1 {
            text-align: center;
            color: #1a2533; /* Darker blue-grey */
            margin: 25px 0;
            font-size: 2em;
            font-weight: 300; /* Lighter font weight for title */
        }
        #controls {
            padding: 12px 10px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            text-align: center;
            flex-shrink: 0;
        }
        #controls button {
            margin: 0 6px;
            padding: 9px 18px;
            font-size: 13.5px;
            background-image: linear-gradient(to right, #007bff 0%, #0056b3 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #controls button:hover:not(:disabled) {
            background-image: linear-gradient(to right, #0056b3 0%, #004085 100%);
            box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            transform: translateY(-1px);
        }
        #controls button:disabled {
            background-image: none;
            background-color: #ced4da;
            cursor: not-allowed;
            box-shadow: none;
        }
        #modeStatus { margin-left: 15px; font-style: italic; color: #495057; }
        .diagram-container-wrapper { flex-grow: 1; width: 100%; overflow: auto; padding: 15px; box-sizing: border-box; }
        .diagram-container {
            width: 1800px; /* Increased width for layout */
            height: 1400px; /* Increased height */
            position: relative;
            border: 1px solid #d1d8e0; 
            background-color: #ffffff;
            border-radius: 10px;
        }
        
        .component {
            position: absolute;
            border-radius: 8px; /* Softer radius */
            padding: 12px 18px; /* More padding */
            text-align: center;
            box-shadow: 0 5px 12px rgba(0,0,0,0.12);
            cursor: grab;
            user-select: none;
            border: none; /* Remove border, rely on gradient/shadow */
            box-sizing: border-box;
            display: flex; 
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease-out;
            color: white; /* Default text color for gradient backgrounds */
        }
        .component:hover {
            box-shadow: 0 7px 20px rgba(0,0,0,0.18);
            transform: translateY(-2px) scale(1.02);
        }
        .component.selected {
            box-shadow: 0 0 0 3.5px rgba(0,123,255,0.5), 0 7px 20px rgba(0,123,255,0.35);
            z-index: 10;
        }
        .component.dragging { cursor: grabbing; opacity: 0.85; z-index: 100; }

        /* Vibrant Gradient Styles for Nodes */
        .script-node { background-image: linear-gradient(135deg, #4e73df 0%, #224abe 100%); } /* Primary Blue */
        .data-node { background-image: linear-gradient(135deg, #1cc88a 0%, #13855c 100%); } /* Success Green */
        .master-df-node { background-image: linear-gradient(135deg, #6f42c1 0%, #4a235a 100%); } /* Indigo/Purple */
        .output-node { background-image: linear-gradient(135deg, #f6c23e 0%, #dda20a 100%); } /* Warning Yellow/Orange */
        
        .node-text {
            font-size: 16px; /* Slightly larger */
            font-weight: 600;
            color: white; /* Text color for gradients */
            margin-bottom: 4px;
        }
         .node-subtext {
            font-size: 14px; /* Slightly larger */
            font-weight: 400;
            color: rgba(255,255,255,0.85); /* Lighter for subtext on dark gradients */
        }

        .arrow-svg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        .arrow-path { stroke-width: 2px; fill: none; pointer-events: stroke; cursor: pointer; transition: stroke 0.2s, stroke-width 0.2s; }
        .arrow-path.selected { stroke-width: 3.5px; stroke: #007bff; }
        .control-arrow { stroke: #4e73df; } 
        .data-arrow { stroke: #1cc88a; stroke-dasharray: 6, 3.5; }
        .config-arrow { stroke: #858796; stroke-dasharray: 4, 2.5; } /* Grey for config */
    </style>
</head>
<body>
    <div class="main-app-container">
        <h1>Interactive Atmospheric Particle Analysis Workflow</h1>
        <div id="controls">
            <button id="addBlockBtn">Add Block</button>
            <button id="addArrowBtn">Add Arrow</button>
            <button id="removeSelectedBtn" disabled>Remove Selected</button>
            <button id="toggleArrowDirBtn" disabled>Toggle Arrow Dir</button>
            <span id="modeStatus"></span>
        </div>
        <div class="diagram-container-wrapper">
            <div class="diagram-container" id="diagramContainer">
                <svg class="arrow-svg-overlay" id="arrowSvg">
                    <defs>
                        <!-- Smaller Arrowheads -->
                        <marker id="arrowhead-control" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" fill="#4e73df"><polygon points="0 0, 7 2.5, 0 5" /></marker>
                        <marker id="arrowhead-data" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" fill="#1cc88a"><polygon points="0 0, 7 2.5, 0 5" /></marker>
                        <marker id="arrowhead-config" markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto" fill="#858796"><polygon points="0 0, 6 2, 0 4" /></marker>
                        
                        <marker id="arrowhead-control-selected" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" fill="#007bff"><polygon points="0 0, 7 2.5, 0 5" /></marker>
                        <marker id="arrowhead-data-selected" markerWidth="7" markerHeight="5" refX="6" refY="2.5" orient="auto" fill="#007bff"><polygon points="0 0, 7 2.5, 0 5" /></marker>
                        <marker id="arrowhead-config-selected" markerWidth="6" markerHeight="4" refX="5" refY="2" orient="auto" fill="#007bff"><polygon points="0 0, 6 2, 0 4" /></marker>
                    </defs>
                    <g id="arrowPathsContainer"></g>
                </svg>
                
                <!-- Components DIVs (initial positions, can be dragged) -->
                <!-- These need to match the IDs used in initialArrowDefs in JS -->
                <div id="configPy" class="component script-node" style="top: 50px; left: 250px; width: 240px; height: 75px;">
                    <span class="node-text">Configuration Parameters</span><span class="node-subtext">(config.py)</span>
                </div>
                <div id="mainWorkflow" class="component script-node" style="top: 200px; left: 250px; width: 240px; height: 75px;">
                    <span class="node-text">Main Orchestrator</span><span class="node-subtext">(main_analysis_workflow.py)</span>
                </div>
                <div id="dataProcessing" class="component script-node" style="top: 350px; left: 250px; width: 240px; height: 75px;">
                    <span class="node-text">Data Processing & Initial Analysis</span><span class="node-subtext">(data_processing.py)</span>
                </div>
                <div id="inputData" class="component data-node" style="top: 500px; left: 50px; width: 220px; height: 75px;">
                    <span class="node-text">Input Data (CSV/NetCDF)</span>
                </div>
                <div id="masterDataFrame" class="component master-df-node" style="top: 500px; left: 350px; width: 240px; height: 75px;">
                    <span class="node-text">Master DataFrame</span>
                </div>
                <div id="tracksAnalysis" class="component script-node" style="top: 150px; left: 750px; width: 220px; height: 75px;">
                    <span class="node-text">Tracks Analysis Module</span><span class="node-subtext">(tracks_analysis.py)</span>
                </div>
                <div id="plotting2D" class="component script-node" style="top: 250px; left: 750px; width: 220px; height: 75px;">
                    <span class="node-text">2D Plotting Module</span><span class="node-subtext">(plotting_2d.py)</span>
                </div>
                <div id="plotting3D" class="component script-node" style="top: 350px; left: 750px; width: 220px; height: 75px;">
                    <span class="node-text">3D Plotting Module</span><span class="node-subtext">(plotting_3d.py)</span>
                </div>
                <div id="statsAnalysis" class="component script-node" style="top: 450px; left: 750px; width: 220px; height: 75px;">
                    <span class="node-text">Statistical Analysis Module</span><span class="node-subtext">(statistical_analysis.py)</span>
                </div>
                <div id="animationsPy" class="component script-node" style="top: 550px; left: 750px; width: 220px; height: 75px;">
                    <span class="node-text">Animation Compilation</span><span class="node-subtext">(animations.py)</span>
                </div>
                <div id="outputFiles" class="component output-node" style="top: 350px; left: 1100px; width: 220px; height: 85px;">
                    <span class="node-text">Output Files</span><span class="node-subtext">(Plots, Data, Animations)</span>
                </div>
            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const diagramContainer = document.getElementById('diagramContainer');
    const arrowSvg = document.getElementById('arrowSvg');
    const arrowPathsContainer = document.getElementById('arrowPathsContainer');
    const ns = "http://www.w3.org/2000/svg";

    let components = {};
    let arrows = {};
    let activeDrag = null;
    let dragOffsetX, dragOffsetY;
    let selectedElement = null, selectedElementType = null;
    let appMode = 'idle';
    let addArrowFromId = null;
    let nextArrowId = 0;
    let nextBlockId = 0;

    // Initialize components
    document.querySelectorAll('.component').forEach(compEl => {
        const id = compEl.id;
        components[id] = {
            el: compEl,
            x: compEl.offsetLeft,
            y: compEl.offsetTop,
            width: compEl.offsetWidth,
            height: compEl.offsetHeight,
            connections: []
        };
        compEl.addEventListener('mousedown', onComponentMouseDown);
        compEl.addEventListener('click', (e) => { e.stopPropagation(); handleComponentClick(id); });
    });
    
    // --- Function to get intersection point with rectangle border ---
    function getIntersectionPointWithRect(rectData, externalPoint) {
        const { x, y, width, height } = rectData;
        const rectCenter = { x: x + width / 2, y: y + height / 2 };

        const dx = externalPoint.x - rectCenter.x;
        const dy = externalPoint.y - rectCenter.y;

        if (dx === 0 && dy === 0) return rectCenter; // Should not happen

        let t = Infinity;
        let intersection = { ...rectCenter }; // Default to center

        // Check top/bottom edges
        if (dy !== 0) {
            let tEdge = (y - rectCenter.y) / dy; // Top edge
            if (tEdge >= 0 && tEdge <= 0.5) { // Ray from center towards external point hits this half-infinite line
                let ix = rectCenter.x + tEdge * dx;
                if (ix >= x && ix <= x + width) { if (Math.abs(tEdge) < Math.abs(t)) { t = tEdge; intersection = { x: ix, y: y }; } }
            }
            tEdge = (y + height - rectCenter.y) / dy; // Bottom edge
            if (tEdge >= 0 && tEdge <= 0.5) {
                let ix = rectCenter.x + tEdge * dx;
                if (ix >= x && ix <= x + width) { if (Math.abs(tEdge) < Math.abs(t)) { t = tEdge; intersection = { x: ix, y: y + height }; } }
            }
        }
        // Check left/right edges
        if (dx !== 0) {
            let tEdge = (x - rectCenter.x) / dx; // Left edge
            if (tEdge >= 0 && tEdge <= 0.5) {
                let iy = rectCenter.y + tEdge * dy;
                if (iy >= y && iy <= y + height) { if (Math.abs(tEdge) < Math.abs(t)) { t = tEdge; intersection = { x: x, y: iy }; } }
            }
            tEdge = (x + width - rectCenter.x) / dx; // Right edge
            if (tEdge >= 0 && tEdge <= 0.5) {
                let iy = rectCenter.y + tEdge * dy;
                if (iy >= y && iy <= y + height) { if (Math.abs(tEdge) < Math.abs(t)) { t = tEdge; intersection = { x: x + width, y: iy }; } }
            }
        }
        // Refined intersection logic: find closest intersection point on border to externalPoint
        // This uses a more standard line-rectangle intersection approach.
        const points = [];
        const
            x1 = rectCenter.x, y1 = rectCenter.y,
            x2 = externalPoint.x, y2 = externalPoint.y;

        // Top edge
        let tTop = ((y - y1) * (x2 - x1) - (x - x1) * (y2 - y1)) / (dy * (x2 - x1) - dx * (y2 - y1)); // This is more complex than needed
        // Simpler approach: check intersections with 4 border lines
        // (https://stackoverflow.com/questions/1829531/how-to-check-if-a-line-segment-intersects-a-rectangle)
        
        // Simplified intersection using angles and distances (effective for arrows from center to border)
        const angle = Math.atan2(dy, dx);
        const halfWidth = width / 2;
        const halfHeight = height / 2;
        
        const tanAngle = Math.tan(angle);
        const edgeDistX = Math.sign(dx) * halfWidth;
        const edgeDistY = Math.sign(dy) * halfHeight;

        let ixBorder = rectCenter.x + edgeDistX;
        let iyBorder = rectCenter.y + edgeDistX * tanAngle;

        if (Math.abs(edgeDistX * tanAngle) > halfHeight) {
            iyBorder = rectCenter.y + edgeDistY;
            ixBorder = rectCenter.x + edgeDistY / tanAngle;
        }
        return { x: Math.round(ixBorder), y: Math.round(iyBorder) };
    }


    const initialArrowDefs = [
        { from: 'configPy', to: 'mainWorkflow', type: 'config' },
        { from: 'configPy', to: 'dataProcessing', type: 'config', pathType: 'curve', cp1Offset: {x: 50, y: 100}, cp2Offset: {x: -20, y: 50}},
        { from: 'mainWorkflow', to: 'dataProcessing', type: 'control' },
        { from: 'mainWorkflow', to: 'tracksAnalysis', type: 'control', pathType: 'curve', cp1Offset: {x:150,y:-20}, cp2Offset:{x:-50,y:20} },
        { from: 'mainWorkflow', to: 'plotting2D', type: 'control', pathType: 'curve', cp1Offset: {x:150,y:0}, cp2Offset:{x:-50,y:0} },
        { from: 'mainWorkflow', to: 'plotting3D', type: 'control', pathType: 'curve', cp1Offset: {x:150,y:20}, cp2Offset:{x:-50,y:-20} },
        { from: 'mainWorkflow', to: 'statsAnalysis', type: 'control', pathType: 'curve', cp1Offset: {x:150,y:40}, cp2Offset:{x:-50,y:-40} },
        { from: 'mainWorkflow', to: 'animationsPy', type: 'control', pathType: 'curve', cp1Offset: {x:150,y:60}, cp2Offset:{x:-50,y:-60} },
        { from: 'inputData', to: 'dataProcessing', type: 'data' },
        { from: 'dataProcessing', to: 'masterDataFrame', type: 'data', pathType: 'curve', cp1Offset: {x:50,y:50}, cp2Offset:{x:-50,y:-20} },
        { from: 'masterDataFrame', to: 'tracksAnalysis', type: 'data' },
        { from: 'masterDataFrame', to: 'plotting2D', type: 'data' },
        { from: 'masterDataFrame', to: 'plotting3D', type: 'data' },
        { from: 'masterDataFrame', to: 'statsAnalysis', type: 'data' },
        { from: 'plotting2D', to: 'animationsPy', type: 'data' },
        { from: 'plotting3D', to: 'animationsPy', type: 'data' },
        { from: 'dataProcessing', to: 'outputFiles', type: 'data', pathType: 'curve', cp1Offset: {x: 200, y: -30}, cp2Offset: {x: -100, y: 0} },
        { from: 'tracksAnalysis', to: 'outputFiles', type: 'data' },
        { from: 'plotting2D', to: 'outputFiles', type: 'data' },
        { from: 'plotting3D', to: 'outputFiles', type: 'data' },
        { from: 'statsAnalysis', to: 'outputFiles', type: 'data' },
        { from: 'animationsPy', to: 'outputFiles', type: 'data' }
    ];

    initialArrowDefs.forEach(def => {
        const id = `arrow-${nextArrowId++}`;
        createArrowElement(id, def.from, def.to, def.type, false, def.pathType, def.cp1Offset, def.cp2Offset);
    });

    function updateArrowPath(arrowId) {
        const arrow = arrows[arrowId];
        if (!arrow || !components[arrow.fromId] || !components[arrow.toId]) return;

        const fromComp = components[arrow.fromId];
        const toComp = components[arrow.toId];

        const fromCenter = { x: fromComp.x + fromComp.width / 2, y: fromComp.y + fromComp.height / 2 };
        const toCenter = { x: toComp.x + toComp.width / 2, y: toComp.y + toComp.height / 2 };
        
        // Get intersection points on borders
        const startPoint = getIntersectionPointWithRect(fromComp, toCenter);
        const endPoint = getIntersectionPointWithRect(toComp, fromCenter);
        
        let d;
        if (arrow.pathType === 'curve' && arrow.cp1Offset && arrow.cp2Offset) {
            const cp1x = startPoint.x + arrow.cp1Offset.x;
            const cp1y = startPoint.y + arrow.cp1Offset.y;
            const cp2x = endPoint.x + arrow.cp2Offset.x; 
            const cp2y = endPoint.y + arrow.cp2Offset.y;
            d = `M ${startPoint.x} ${startPoint.y} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${endPoint.x} ${endPoint.y}`;
        } else {
            d = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
        }
        arrow.el.setAttribute('d', d);
    }
    // ... (rest of createArrowElement, dragging, selection, and control button logic from previous complex interactive script) ...
    // Ensure createArrowElement calls updateArrowPath.
    // Ensure onDrag updates relevant arrows.
    // Placeholder for brevity, but the full interactive logic is needed here.
    function createArrowElement(id, fromId, toId, type, isBidirectional = false, pathType = 'straight', cp1Offset, cp2Offset) {
        if (!components[fromId] || !components[toId]) { return; }
        const path = document.createElementNS(ns, 'path');
        path.setAttribute('id', id);
        path.classList.add('arrow-path', `${type}-arrow`);
        path.setAttribute('marker-end', `url(#arrowhead-${type}${selectedElement === path ? '-selected':''})`);
        if (isBidirectional) { /* ... */ }
        arrowPathsContainer.appendChild(path);
        arrows[id] = { el: path, fromId, toId, type, isBidirectional, pathType, cp1Offset, cp2Offset };
        components[fromId].connections.push(id);
        components[toId].connections.push(id);
        updateArrowPath(id);
        path.addEventListener('click', (e) => { e.stopPropagation(); selectElement(path, 'arrow'); });
    }
    function onComponentMouseDown(e) { /* ... same as before ... */ 
        if (e.button !== 0) return;
        const targetEl = e.currentTarget;
        if (appMode === 'idle') {
            activeDrag = targetEl;
            targetEl.classList.add('dragging');
            dragOffsetX = e.clientX - targetEl.offsetLeft;
            dragOffsetY = e.clientY - targetEl.offsetTop;
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', onDragEnd);
            selectElement(targetEl, 'component');
        }
    }
    function handleComponentClick(blockId) { /* ... same as before ... */ 
         if (appMode === 'addingArrow_selectFrom') {
            addArrowFromId = blockId;
            components[blockId].el.classList.add('selected'); 
            appMode = 'addingArrow_selectTo';
            document.getElementById('modeStatus').textContent = 'Select TO block...';
        } else if (appMode === 'addingArrow_selectTo') {
            if (addArrowFromId && addArrowFromId !== blockId) {
                const type = prompt("Arrow type (control, data, config):", "control") || "control";
                const newId = `arrow-${nextArrowId++}`;
                createArrowElement(newId, addArrowFromId, blockId, type);
            }
            if (components[addArrowFromId]) components[addArrowFromId].el.classList.remove('selected');
            addArrowFromId = null;
            appMode = 'idle';
            document.getElementById('modeStatus').textContent = '';
        } else {
            selectElement(components[blockId].el, 'component');
        }
    }
    function onDrag(e) { /* ... same as before ... */ 
        if (!activeDrag) return;
        e.preventDefault();
        let newX = e.clientX - dragOffsetX;
        let newY = e.clientY - dragOffsetY;
        newX = Math.max(0, Math.min(newX, diagramContainer.offsetWidth - activeDrag.offsetWidth));
        newY = Math.max(0, Math.min(newY, diagramContainer.offsetHeight - activeDrag.offsetHeight));
        activeDrag.style.left = newX + 'px';
        activeDrag.style.top = newY + 'px';
        const compData = components[activeDrag.id];
        compData.x = newX;
        compData.y = newY;
        compData.connections.forEach(arrowId => updateArrowPath(arrowId));
    }
    function onDragEnd() { /* ... same as before ... */ 
        if (!activeDrag) return;
        activeDrag.classList.remove('dragging');
        activeDrag = null;
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', onDragEnd);
    }
    function selectElement(element, type) { /* ... same, including marker updates ... */ 
        if (selectedElement) {
            selectedElement.classList.remove('selected');
             if (selectedElementType === 'arrow' && arrows[selectedElement.id]) {
                const arrowData = arrows[selectedElement.id];
                arrowData.el.setAttribute('marker-end', `url(#arrowhead-${arrowData.type})`);
                if (arrowData.isBidirectional) arrowData.el.setAttribute('marker-start', `url(#arrowhead-${arrowData.type}-start)`);
            }
        }
        selectedElement = element;
        selectedElementType = type;
        if (selectedElement) {
            selectedElement.classList.add('selected');
            if (type === 'arrow' && arrows[element.id]) { 
                 const arrowData = arrows[element.id];
                arrowData.el.setAttribute('marker-end', `url(#arrowhead-${arrowData.type}-selected)`);
                 if (arrowData.isBidirectional) arrowData.el.setAttribute('marker-start', `url(#arrowhead-${arrowData.type}-start-selected)`);
            }
        }
        updateButtonStates();
    }
    diagramContainer.addEventListener('click', (e) => { /* ... same ... */ 
        if (e.target === diagramContainer) { 
             if (appMode.startsWith('addingArrow')) {
                if (addArrowFromId && components[addArrowFromId]) components[addArrowFromId].el.classList.remove('selected');
                addArrowFromId = null;
                appMode = 'idle';
                document.getElementById('modeStatus').textContent = '';
            } else {
                selectElement(null, null);
            }
        }
    });
    function updateButtonStates() { /* ... same ... */ 
        document.getElementById('removeSelectedBtn').disabled = !selectedElement;
        document.getElementById('toggleArrowDirBtn').disabled = !(selectedElement && selectedElementType === 'arrow');
    }
    document.getElementById('addArrowBtn').addEventListener('click', () => { /* ... same ... */ 
        if (appMode === 'idle') {
            appMode = 'addingArrow_selectFrom';
            document.getElementById('modeStatus').textContent = 'Select FROM block...';
            selectElement(null,null);
        } else {
            if (addArrowFromId && components[addArrowFromId]) components[addArrowFromId].el.classList.remove('selected');
            addArrowFromId = null;
            appMode = 'idle';
            document.getElementById('modeStatus').textContent = '';
        }
    });
    document.getElementById('removeSelectedBtn').addEventListener('click', () => { /* ... same ... */ 
        if (!selectedElement) return;
        if (selectedElementType === 'component') {
            const compId = selectedElement.id;
            if (components[compId]) {
                [...components[compId].connections].forEach(arrowId => removeArrow(arrowId));
                components[compId].el.remove();
                delete components[compId];
            }
        } else if (selectedElementType === 'arrow') {
            removeArrow(selectedElement.id);
        }
        selectElement(null, null);
    });
    function removeArrow(arrowId) { /* ... same ... */ 
        const arrow = arrows[arrowId];
        if (!arrow) return;
        if (components[arrow.fromId]) components[arrow.fromId].connections = components[arrow.fromId].connections.filter(id => id !== arrowId);
        if (components[arrow.toId]) components[arrow.toId].connections = components[arrow.toId].connections.filter(id => id !== arrowId);
        arrow.el.remove();
        delete arrows[arrowId];
    }
    document.getElementById('toggleArrowDirBtn').addEventListener('click', () => { /* ... same ... */ 
        if (!selectedElement || selectedElementType !== 'arrow') return;
        const arrow = arrows[selectedElement.id];
        arrow.isBidirectional = !arrow.isBidirectional;
        const isSelected = selectedElement.classList.contains('selected');
        const startMarkerSuffix = isSelected ? '-start-selected' : '-start';
        const endMarkerSuffix = isSelected ? '-selected' : '';

        if (arrow.isBidirectional) {
             arrow.el.setAttribute('marker-start', `url(#arrowhead-${arrow.type}${startMarkerSuffix})`);
        } else {
            arrow.el.removeAttribute('marker-start');
        }
         arrow.el.setAttribute('marker-end', `url(#arrowhead-${arrow.type}${endMarkerSuffix})`); // Ensure end marker is correct
    });
    document.getElementById('addBlockBtn').addEventListener('click', () => { /* ... same ... */ 
        const id = `customBlock-${nextBlockId++}`;
        const newBlock = document.createElement('div');
        newBlock.id = id;
        newBlock.classList.add('component', 'script-node'); 
        newBlock.style.left = '20px'; newBlock.style.top = '20px';
        newBlock.style.width = '200px'; newBlock.style.height = '70px';
        newBlock.innerHTML = `<span class="node-text">New Block</span><span class="node-subtext">(custom)</span>`;
        diagramContainer.appendChild(newBlock);
        components[id] = { el: newBlock, x: 20, y: 20, width: 200, height: 70, connections: [] };
        newBlock.addEventListener('mousedown', onComponentMouseDown);
        newBlock.addEventListener('click', (e) => { e.stopPropagation(); handleComponentClick(id); });
        selectElement(newBlock, 'component');
    });

    console.log("Interactive workflow diagram initialized - border arrows.");
});
</script>
</body>
</html>