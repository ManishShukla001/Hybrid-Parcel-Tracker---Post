<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Main Analysis Workflow Stages</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; /* Ensure body takes at least full height */
            padding: 20px 0; /* Add some padding */
            box-sizing: border-box;
        }
        .main-app-container {
            width: 95%;
            max-width: 1000px; /* Adjusted for a more vertical layout */
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        h1 {
            text-align: center;
            color: #1a2533;
            margin: 25px 0;
            font-size: 1.8em;
            font-weight: 300;
        }
        #controls { /* Basic controls, can be hidden if not needed for this chart */
            padding: 10px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
            text-align: center;
            flex-shrink: 0;
            display: none; /* Hidden by default for this flowchart */
        }
        .diagram-container-wrapper {
            flex-grow: 1;
            width: 100%;
            overflow: auto; 
            padding: 15px;
            box-sizing: border-box;
        }
        .diagram-container {
            width: 900px;  /* Width can be smaller for a vertical flow */
            height: 2300px; /* Tall enough for all stages */
            position: relative; 
            border: 1px solid #d1d8e0; 
            background-color: #ffffff;
            border-radius: 10px;
        }
        
        .flowchart-stage {
            position: absolute;
            border-radius: 10px; /* More rounded */
            padding: 15px 20px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            cursor: grab;
            user-select: none;
            border: none; 
            box-sizing: border-box;
            display: flex; 
            flex-direction: column;
            align-items: flex-start; /* Align text to the left */
            text-align: left;
            color: white;
            background-image: linear-gradient(135deg, #5D6D7E 0%, #34495E 100%); /* Neutral Dark Blue/Grey */
            transition: all 0.2s ease-out;
        }
        .flowchart-stage:hover {
            box-shadow: 0 8px 22px rgba(0,0,0,0.15);
            transform: translateY(-2px) scale(1.01);
        }
        .flowchart-stage.selected {
            box-shadow: 0 0 0 3.5px rgba(0,123,255,0.5), 0 8px 22px rgba(0,123,255,0.35);
            z-index: 10;
        }
        .stage-title {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
            padding-bottom: 8px;
            width: 100%;
        }
        .stage-detail {
            font-size: 13px;
            line-height: 1.6;
            margin-bottom: 5px;
        }
        .stage-detail strong {
            font-weight: 600;
            color: rgba(255,255,255,0.9);
        }
        .stage-detail code {
            background-color: rgba(0,0,0,0.1);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 12px;
            color: #f1c40f; /* Yellow for code */
        }

        .arrow-svg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        .arrow-path { stroke-width: 2.5px; fill: none; pointer-events: stroke; cursor: pointer; transition: stroke 0.2s, stroke-width 0.2s; }
        .flow-arrow { stroke: #3498db; } /* Consistent blue for flow */
        .arrow-path.selected { stroke-width: 4px; stroke: #0056b3; }
    </style>
</head>
<body>
    <div class="main-app-container">
        <h1>Main Analysis Workflow Stages</h1>
        <div id="controls">
            <button id="addBlockBtn">Add Stage</button>
            <button id="addArrowBtn">Add Arrow</button>
            <button id="removeSelectedBtn" disabled>Remove Selected</button>
        </div>
        <div class="diagram-container-wrapper">
            <div class="diagram-container" id="diagramContainer">
                <svg class="arrow-svg-overlay" id="arrowSvg">
                    <defs>
                        <marker id="arrowhead-flow" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" fill="#3498db"><polygon points="0 0, 8 3, 0 6" /></marker>
                        <marker id="arrowhead-flow-selected" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" fill="#0056b3"><polygon points="0 0, 8 3, 0 6" /></marker>
                    </defs>
                    <g id="arrowPathsContainer"></g>
                </svg>
                
                <!-- Flowchart Stages (DIVs) -->
                <div id="stageSetup" class="flowchart-stage" style="top: 50px; left: 200px; width: 500px; min-height: 100px;">
                    <div class="stage-title">Setup</div>
                    <div class="stage-detail"><strong>Action:</strong> Initialize logging, Create output directories, Calculate derived configurations.</div>
                </div>

                <div id="stage1" class="flowchart-stage" style="top: 200px; left: 200px; width: 500px; min-height: 120px;">
                    <div class="stage-title">Stage 1: Identify Relevant Particle IDs</div>
                    <div class="stage-detail"><strong>Action:</strong> Calls <code>data_processing.identify_target_particles_from_augmented_data()</code>.</div>
                    <div class="stage-detail"><strong>Input:</strong> Augmented Particle Data (CSV/NetCDF).</div>
                    <div class="stage-detail"><strong>Output:</strong> List of relevant particle IDs (CSV file).</div>
                </div>

                <div id="stage2" class="flowchart-stage" style="top: 370px; left: 200px; width: 500px; min-height: 120px;">
                    <div class="stage-title">Stage 2: Extract Full Histories</div>
                    <div class="stage-detail"><strong>Action:</strong> Calls <code>data_processing.extract_particle_histories()</code>.</div>
                    <div class="stage-detail"><strong>Input:</strong> Relevant IDs, Augmented Data.</div>
                    <div class="stage-detail"><strong>Output:</strong> Filtered hourly data (CSVs).</div>
                </div>
                
                <div id="stage3" class="flowchart-stage" style="top: 540px; left: 200px; width: 500px; min-height: 120px;">
                    <div class="stage-title">Stage 3: Analyze Histories</div>
                    <div class="stage-detail"><strong>Action:</strong> Calls <code>data_processing.analyze_all_particle_histories_detailed()</code>.</div>
                    <div class="stage-detail"><strong>Input:</strong> Filtered hourly data.</div>
                    <div class="stage-detail"><strong>Output:</strong> Analyzed particle CSVs (&Delta;q, &Delta;T, events, etc.).</div>
                </div>

                <div id="stage4" class="flowchart-stage" style="top: 710px; left: 200px; width: 500px; min-height: 120px;">
                    <div class="stage-title">Stage 4: Load Master DataFrame</div>
                    <div class="stage-detail"><strong>Action:</strong> Calls <code>data_processing.load_master_analyzed_df()</code>.</div>
                    <div class="stage-detail"><strong>Input:</strong> Analyzed particle CSVs.</div>
                    <div class="stage-detail"><strong>Output:</strong> <code>master_df</code> (Pandas DataFrame).</div>
                </div>

                <div id="stage5" class="flowchart-stage" style="top: 880px; left: 200px; width: 500px; min-height: 120px;">
                    <div class="stage-title">Stage 5: Tracks Analysis</div>
                    <div class="stage-detail"><strong>Action:</strong> Calls <code>tracks_analysis.run_tracks_analysis_from_master()</code>.</div>
                    <div class="stage-detail"><strong>Input:</strong> <code>master_df</code>, Config.</div>
                    <div class="stage-detail"><strong>Output:</strong> Tracks-specific plots & data CSVs.</div>
                </div>

                <div id="stage6" class="flowchart-stage" style="top: 1050px; left: 200px; width: 500px; min-height: 140px;">
                    <div class="stage-title">Stage 6: Generate Plots & Animations</div>
                    <div class="stage-detail"><strong>Action:</strong> Calls functions from <code>plotting_2d.py</code>, <code>plotting_3d.py</code>, <code>statistical_analysis.py</code>, <code>animations.py</code>.</div>
                    <div class="stage-detail"><strong>Input:</strong> <code>master_df</code>, Config.</div>
                    <div class="stage-detail"><strong>Output:</strong> Various plots (PNGs) and animations (GIFs/MP4s).</div>
                </div>
                
                <!-- End (Conceptual, not explicitly requested as an oval for sequential flow end) -->
                <div id="endFlow" class="flowchart-stage" style="top: 1240px; left: 350px; width: 200px; height: 60px; background-image: linear-gradient(135deg, #85c1e9 0%, #3498db 100%);">
                     <div class="stage-title" style="text-align:center; border-bottom:none;">Workflow End</div>
                </div>

            </div>
        </div>
    </div>

<script>
// --- Standard Interactive Diagram JavaScript (adapted) ---
document.addEventListener('DOMContentLoaded', () => {
    const diagramContainer = document.getElementById('diagramContainer');
    const arrowSvg = document.getElementById('arrowSvg');
    const arrowPathsContainer = document.getElementById('arrowPathsContainer');
    const ns = "http://www.w3.org/2000/svg";

    let components = {};
    let arrows = {};
    let activeDrag = null;
    let dragOffsetX, dragOffsetY;
    let selectedElement = null, selectedElementType = null;
    // Controls are hidden by default, so appMode/addArrow logic is less critical here
    // but kept for consistency if controls are enabled.
    let appMode = 'idle'; 
    let addArrowFromId = null;
    let nextArrowId = 0;

    // Initialize components
    document.querySelectorAll('.flowchart-stage').forEach(compEl => {
        const id = compEl.id;
        components[id] = {
            el: compEl,
            x: compEl.offsetLeft,
            y: compEl.offsetTop,
            width: compEl.offsetWidth,
            height: compEl.offsetHeight,
            connections: [] // Stores IDs of arrows connected to this block
        };
        compEl.addEventListener('mousedown', onComponentMouseDown);
        compEl.addEventListener('click', (e) => { e.stopPropagation(); selectElement(compEl, 'component'); });
    });
    
    function getIntersectionPointWithRect(rectData, externalPoint, isStartPoint) {
        const { x, y, width, height } = rectData;
        const rectCenter = { x: x + width / 2, y: y + height / 2 };
        const point = externalPoint; // The center of the other block

        const dx = point.x - rectCenter.x;
        const dy = point.y - rectCenter.y;

        let t = 0.5; // Start with assuming intersection is on the border (t=0.5 along vector from center to border)
        let edge = null;

        // Check intersection with vertical edges
        if (dx !== 0) {
            const tEdgeLeft = (x - rectCenter.x) / dx;
            const tEdgeRight = (x + width - rectCenter.x) / dx;
            if (dx > 0) { // Point is to the right of center
                if (tEdgeRight < t && tEdgeRight >=0) { t = tEdgeRight; edge = 'right';}
            } else { // Point is to the left of center
                if (tEdgeLeft < t && tEdgeLeft >=0) { t = tEdgeLeft; edge = 'left';}
            }
        }
        // Check intersection with horizontal edges
        if (dy !== 0) {
            const tEdgeTop = (y - rectCenter.y) / dy;
            const tEdgeBottom = (y + height - rectCenter.y) / dy;
             if (dy > 0) { // Point is below center
                if (tEdgeBottom < t && tEdgeBottom >=0) { t = tEdgeBottom; edge = 'bottom';}
            } else { // Point is above center
                if (tEdgeTop < t && tEdgeTop >=0) { t = tEdgeTop; edge = 'top';}
            }
        }
        
        if (edge === 'top') return { x: rectCenter.x + t * dx, y: y };
        if (edge === 'bottom') return { x: rectCenter.x + t * dx, y: y + height };
        if (edge === 'left') return { x: x, y: rectCenter.y + t * dy };
        if (edge === 'right') return { x: x + width, y: rectCenter.y + t * dy };

        // Fallback for points directly aligned or inside (rare for distinct blocks)
        // For vertical flow, prioritize top/bottom connection points
        if (isStartPoint) return { x: rectCenter.x, y: y + height }; // Arrow starts from bottom center
        return { x: rectCenter.x, y: y }; // Arrow ends at top center
    }


    const initialArrowDefs = [
        { from: 'stageSetup', to: 'stage1', type: 'flow' },
        { from: 'stage1', to: 'stage2', type: 'flow' },
        { from: 'stage2', to: 'stage3', type: 'flow' },
        { from: 'stage3', to: 'stage4', type: 'flow' },
        { from: 'stage4', to: 'stage5', type: 'flow' },
        { from: 'stage5', to: 'stage6', type: 'flow' },
        { from: 'stage6', to: 'endFlow', type: 'flow' }
    ];

    initialArrowDefs.forEach(def => {
        const id = `arrow-${nextArrowId++}`;
        createArrowElement(id, def.from, def.to, def.type);
    });

    function updateArrowPath(arrowId) {
        const arrow = arrows[arrowId];
        if (!arrow || !components[arrow.fromId] || !components[arrow.toId]) return;

        const fromComp = components[arrow.fromId];
        const toComp = components[arrow.toId];
        
        const fromCenter = { x: fromComp.x + fromComp.width / 2, y: fromComp.y + fromComp.height / 2 };
        const toCenter = { x: toComp.x + toComp.width / 2, y: toComp.y + toComp.height / 2 };

        const startPoint = getIntersectionPointWithRect(fromComp, toCenter, true); // true for isStartPoint
        const endPoint = getIntersectionPointWithRect(toComp, fromCenter, false); // false for isStartPoint

        // For mostly vertical flow, make paths go straight down then across if needed
        let d;
        const midY = (startPoint.y + endPoint.y) / 2;
        if (Math.abs(startPoint.x - endPoint.x) < fromComp.width / 2) { // If mostly vertical
             d = `M ${startPoint.x} ${startPoint.y} L ${startPoint.x} ${midY} L ${endPoint.x} ${midY} L ${endPoint.x} ${endPoint.y}`;
        } else { // More diagonal, simple line or S-curve
             d = `M ${startPoint.x} ${startPoint.y} V ${midY} H ${endPoint.x} V ${endPoint.y}`;
           // d = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
        }
        arrow.el.setAttribute('d', d);
    }

    function createArrowElement(id, fromId, toId, type) {
        if (!components[fromId] || !components[toId]) { return; }
        const path = document.createElementNS(ns, 'path');
        path.setAttribute('id', id);
        path.classList.add('arrow-path', `${type}-arrow`);
        path.setAttribute('marker-end', `url(#arrowhead-${type}${selectedElement === path ? '-selected':''})`);
        arrowPathsContainer.appendChild(path);
        arrows[id] = { el: path, fromId, toId, type };
        components[fromId].connections.push(id);
        components[toId].connections.push(id);
        updateArrowPath(id);
        path.addEventListener('click', (e) => { e.stopPropagation(); selectElement(path, 'arrow'); });
    }

    function onComponentMouseDown(e) {
        if (e.button !== 0) return;
        activeDrag = e.currentTarget;
        activeDrag.classList.add('selected'); // Select on drag start
        dragOffsetX = e.clientX - activeDrag.offsetLeft;
        dragOffsetY = e.clientY - activeDrag.offsetTop;
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', onDragEnd);
        selectElement(activeDrag, 'component');
    }

    function onDrag(e) {
        if (!activeDrag) return;
        e.preventDefault();
        let newX = e.clientX - dragOffsetX;
        let newY = e.clientY - dragOffsetY;
        newX = Math.max(0, Math.min(newX, diagramContainer.offsetWidth - activeDrag.offsetWidth));
        newY = Math.max(0, Math.min(newY, diagramContainer.offsetHeight - activeDrag.offsetHeight));
        activeDrag.style.left = newX + 'px';
        activeDrag.style.top = newY + 'px';
        const compData = components[activeDrag.id];
        compData.x = newX;
        compData.y = newY;
        compData.connections.forEach(arrowId => updateArrowPath(arrowId));
    }

    function onDragEnd() {
        if (!activeDrag) return;
        // activeDrag.classList.remove('dragging'); // Keep selected
        activeDrag = null;
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', onDragEnd);
    }

    function selectElement(element, type) {
        if (selectedElement) {
            selectedElement.classList.remove('selected');
             if (selectedElementType === 'arrow' && arrows[selectedElement.id]) {
                const arrowData = arrows[selectedElement.id];
                arrowData.el.setAttribute('marker-end', `url(#arrowhead-${arrowData.type})`);
            }
        }
        selectedElement = element;
        selectedElementType = type;
        if (selectedElement) {
            selectedElement.classList.add('selected');
            if (type === 'arrow' && arrows[element.id]) { 
                 const arrowData = arrows[element.id];
                arrowData.el.setAttribute('marker-end', `url(#arrowhead-${arrowData.type}-selected)`);
            }
        }
        // Update button states if controls are visible
        // const controls = document.getElementById('controls');
        // if (controls.style.display !== 'none') updateButtonStates();
    }
    
    diagramContainer.addEventListener('click', (e) => {
        if (e.target === diagramContainer) selectElement(null, null);
    });

    // Simplified: Hide controls and related button update logic for this specific flowchart.
    // function updateButtonStates() { /* ... */ }
    // document.getElementById('addArrowBtn').addEventListener('click', () => { /* ... */ });
    // document.getElementById('removeSelectedBtn').addEventListener('click', () => { /* ... */ });
    // etc.

    console.log("Interactive flowchart initialized.");
});
</script>
</body>
</html>