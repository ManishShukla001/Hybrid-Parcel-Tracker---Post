<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation Generation Workflow</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh; 
            padding: 20px 0; 
            box-sizing: border-box;
        }
        .main-app-container {
            width: 95%;
            max-width: 1100px; /* Wider to accommodate parallel steps */
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.08);
            overflow: hidden;
        }
        h1 {
            text-align: center;
            color: #1a2533;
            margin: 25px 0;
            font-size: 1.8em;
            font-weight: 300;
        }
         .subtitle-flowchart {
            text-align: center;
            color: #566573;
            margin-bottom: 25px;
            font-size: 0.9em;
            font-style: italic;
        }
        #controls { display: none; /* Hidden by default */ }
        .diagram-container-wrapper {
            flex-grow: 1;
            width: 100%;
            overflow: auto; 
            padding: 15px;
            box-sizing: border-box;
        }
        .diagram-container {
            width: 1000px; 
            height: 1500px; /* Tall enough for all stages */
            position: relative; 
            border: 1px solid #d1d8e0; 
            background-color: #ffffff;
            border-radius: 10px;
        }
        
        .flowchart-process, .flowchart-loop-header { /* Common style for process blocks */
            position: absolute;
            border-radius: 10px; 
            padding: 15px 20px;
            box-shadow: 0 6px 15px rgba(0,0,0,0.1);
            cursor: grab;
            user-select: none;
            border: none; 
            box-sizing: border-box;
            display: flex; 
            flex-direction: column;
            /* align-items: flex-start;  Align text to the left for details */
            /* text-align: left; */
            align-items: center; /* Center title */
            text-align: center;
            color: white;
            background-image: linear-gradient(135deg, #17A2B8 0%, #117A8B 100%); /* Info Teal/Blue */
            transition: all 0.2s ease-out;
        }
        .flowchart-process:hover, .flowchart-loop-header:hover {
            box-shadow: 0 8px 22px rgba(0,0,0,0.15);
            transform: translateY(-2px) scale(1.01);
        }
        .flowchart-process.selected, .flowchart-loop-header.selected {
            box-shadow: 0 0 0 3.5px rgba(23,162,184,0.6), 0 8px 22px rgba(23,162,184,0.4);
            z-index: 10;
        }
        .process-title { /* For main title of the box */
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 8px;
            width: 100%;
            text-align: center;
        }
        .process-detail { /* For action/input/output sub-text */
            font-size: 12px;
            line-height: 1.5;
            margin-top: 5px;
            width: 100%;
            text-align: left; /* Details can be left aligned */
            color: rgba(255,255,255,0.9);
        }
        .process-detail strong { font-weight: 600; }
        .process-detail code {
            background-color: rgba(0,0,0,0.2);
            padding: 1px 4px;
            border-radius: 3px;
            font-size: 11px;
            color: #ffc107; /* Amber for code */
        }
        .loop-boundary-visual { /* Visual rectangle for the loop area */
            position: absolute;
            border: 2px dashed #7f8c8d;
            border-radius: 15px;
            background-color: rgba(127, 140, 141, 0.05);
            pointer-events: none; /* So it doesn't interfere with dragging blocks inside */
        }


        .arrow-svg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 0; }
        .arrow-path { stroke-width: 2.5px; fill: none; pointer-events: stroke; cursor: pointer; transition: stroke 0.2s, stroke-width 0.2s; }
        .flow-arrow { stroke: #117A8B; } 
        .arrow-path.selected { stroke-width: 4px; stroke: #0056b3; }
        .flow-label { font-family: 'Segoe UI',Tahoma,Geneva,Verdana,sans-serif; font-size: 12px; fill: #566573; text-anchor:middle; font-weight:500; }

    </style>
</head>
<body>
    <div class="main-app-container">
        <h1>Animation Generation Process</h1>
        <p class="subtitle-flowchart"><code>animations.create_all_animations</code> function</p>
        <div id="controls"></div>
        <div class="diagram-container-wrapper">
            <div class="diagram-container" id="diagramContainer">
                <svg class="arrow-svg-overlay" id="arrowSvg">
                    <defs>
                        <marker id="arrowhead-flow" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" fill="#117A8B"><polygon points="0 0, 8 3, 0 6" /></marker>
                        <marker id="arrowhead-flow-selected" markerWidth="8" markerHeight="6" refX="7" refY="3" orient="auto" fill="#0056b3"><polygon points="0 0, 8 3, 0 6" /></marker>
                    </defs>
                    <g id="arrowPathsContainer"></g>
                </svg>
                
                <!-- Flowchart Steps (DIVs) -->
                <div id="animSetup" class="flowchart-process" style="top: 50px; left: 250px; width: 500px; min-height: 90px;">
                    <div class="process-title">Setup</div>
                    <div class="process-detail"><strong>Action:</strong> Create output directories for animation frames and final animations.</div>
                </div>

                <div id="calcNorms" class="flowchart-process" style="top: 190px; left: 250px; width: 500px; min-height: 100px;">
                    <div class="process-title">Calculate Global Norms & Extents</div>
                    <div class="process-detail"><strong>Action:</strong> Determine consistent color scales (q, T) and plot boundaries (2D/3D limits) for all frames.</div>
                </div>

                <div id="genColorbars" class="flowchart-process" style="top: 340px; left: 250px; width: 500px; min-height: 90px;">
                    <div class="process-title">Generate Static Colorbars</div>
                    <div class="process-detail"><strong>Action:</strong> Create and save separate colorbar images for q and T.</div>
                </div>

                <!-- Loop Start -->
                <div id="loopHeader" class="flowchart-loop-header" style="top: 480px; left: 150px; width: 700px; height: 60px; background-image: linear-gradient(135deg, #6c757d 0%, #343a40 100%);">
                    <div class="process-title">Loop: For each hour in Animation Range</div>
                </div>
                <div id="loopVisualBoundary" class="loop-boundary-visual" style="top: 550px; left: 100px; width: 800px; height: 330px;"></div>

                <!-- Frame Generation (Inside Loop Area) - Parallel Layout -->
                <div id="frame2Dq" class="flowchart-process" style="top: 600px; left: 120px; width: 320px; min-height: 90px;">
                    <div class="process-title">Generate 2D Snapshot Frame (q)</div>
                    <div class="process-detail"><strong>Action:</strong> Calls <code>plotting_2d.generate_2d_snapshot_frame</code></div>
                </div>
                <div id="frame2DT" class="flowchart-process" style="top: 600px; left: 560px; width: 320px; min-height: 90px;">
                    <div class="process-title">Generate 2D Snapshot Frame (T)</div>
                    <div class="process-detail"><strong>Action:</strong> Calls <code>plotting_2d.generate_2d_snapshot_frame</code></div>
                </div>
                <div id="frame3Dq" class="flowchart-process" style="top: 740px; left: 120px; width: 320px; min-height: 90px;">
                    <div class="process-title">Generate 3D Snapshot Frame (q)</div>
                    <div class="process-detail"><strong>Action:</strong> Calls <code>plotting_3d.generate_3d_snapshot_frame</code></div>
                </div>
                <div id="frame3DT" class="flowchart-process" style="top: 740px; left: 560px; width: 320px; min-height: 90px;">
                    <div class="process-title">Generate 3D Snapshot Frame (T)</div>
                    <div class="process-detail"><strong>Action:</strong> Calls <code>plotting_3d.generate_3d_snapshot_frame</code></div>
                </div>
                <!-- Loop End (Conceptual - arrow goes back to loopHeader or out) -->
                <div id="loopExitLabel" style="position:absolute; top: 890px; left: 450px; text-align:center;">
                    <span class="flow-label">All hours processed</span>
                </div>


                <!-- Compile Animations (After Loop) - Parallel Layout -->
                <div id="compile2D" class="flowchart-process" style="top: 980px; left: 100px; width: 380px; min-height: 110px;">
                    <div class="process-title">Compile 2D Animations</div>
                    <div class="process-detail"><strong>Action:</strong> Compile 2D q frames into GIF/MP4.</div>
                    <div class="process-detail"><strong>Action:</strong> Compile 2D T frames into GIF/MP4.</div>
                </div>
                <div id="compile3D" class="flowchart-process" style="top: 980px; left: 520px; width: 380px; min-height: 110px;">
                    <div class="process-title">Compile 3D Animations</div>
                    <div class="process-detail"><strong>Action:</strong> Compile 3D q frames into GIF/MP4.</div>
                    <div class="process-detail"><strong>Action:</strong> Compile 3D T frames into GIF/MP4.</div>
                </div>

                 <div id="endAnimFlow" class="flowchart-process" style="top: 1140px; left: 400px; width: 200px; height: 60px; background-image: linear-gradient(135deg, #85c1e9 0%, #5dade2 100%);">
                     <div class="process-title" style="border-bottom:none;">Workflow End</div>
                </div>

            </div>
        </div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const diagramContainer = document.getElementById('diagramContainer');
    const arrowSvg = document.getElementById('arrowSvg');
    const arrowPathsContainer = document.getElementById('arrowPathsContainer');
    const ns = "http://www.w3.org/2000/svg";

    let components = {};
    let arrows = {};
    let activeDrag = null;
    let dragOffsetX, dragOffsetY;
    let selectedElement = null, selectedElementType = null;
    let nextArrowId = 0;

    // Initialize components
    document.querySelectorAll('.flowchart-process, .flowchart-loop-header').forEach(compEl => {
        const id = compEl.id;
        components[id] = {
            el: compEl,
            x: compEl.offsetLeft,
            y: compEl.offsetTop,
            width: compEl.offsetWidth,
            height: compEl.offsetHeight,
            connections: []
        };
        compEl.addEventListener('mousedown', onComponentMouseDown);
        compEl.addEventListener('click', (e) => { e.stopPropagation(); selectElement(compEl, 'component'); });
    });
    
    function getPortCoordinates(rectData, side = 'bottom', offsetFraction = 0.5) {
        // side can be 'top', 'bottom', 'left', 'right'
        // offsetFraction is from 0 to 1 along that side
        let x, y;
        if (side === 'top') {
            x = rectData.x + rectData.width * offsetFraction;
            y = rectData.y;
        } else if (side === 'bottom') {
            x = rectData.x + rectData.width * offsetFraction;
            y = rectData.y + rectData.height;
        } else if (side === 'left') {
            x = rectData.x;
            y = rectData.y + rectData.height * offsetFraction;
        } else { // right
            x = rectData.x + rectData.width;
            y = rectData.y + rectData.height * offsetFraction;
        }
        return {x, y};
    }


    const initialArrowDefs = [
        { from: 'animSetup', to: 'calcNorms', type: 'flow', fromSide: 'bottom', toSide: 'top'},
        { from: 'calcNorms', to: 'genColorbars', type: 'flow', fromSide: 'bottom', toSide: 'top'},
        { from: 'genColorbars', to: 'loopHeader', type: 'flow', fromSide: 'bottom', toSide: 'top'},
        
        // Arrows into loop content (from loopHeader bottom to top of frame gen blocks)
        // A bit tricky to make these look good automatically, might need manual path for a "bus"
        { from: 'loopHeader', to: 'frame2Dq', type: 'flow', fromSide: 'bottom', toSide: 'top', fromOffset: 0.3, toOffset: 0.5},
        { from: 'loopHeader', to: 'frame2DT', type: 'flow', fromSide: 'bottom', toSide: 'top', fromOffset: 0.7, toOffset: 0.5},
        // Assuming 3D frames are also triggered "per hour"
        { from: 'loopHeader', to: 'frame3Dq', type: 'flow', fromSide: 'bottom', toSide: 'top', fromOffset: 0.3, toOffset: 0.5},
        { from: 'loopHeader', to: 'frame3DT', type: 'flow', fromSide: 'bottom', toSide: 'top', fromOffset: 0.7, toOffset: 0.5},

        // Loop exit: conceptually from the bottom of the loop area to compilation steps
        // Using a dummy invisible point or just connecting from loopHeader with different path
        // For now, simple connections assuming loop content finishes and flow continues
        // We'll use loopExitLabel's approximate position as a conceptual exit point.
        // This needs a more robust way if loopExitLabel is draggable or dynamic.
        // Let's connect from the bottom of the loop boundary visually.
        // Arrow from loop to compile steps - these will be more complex paths.
        // We will define a conceptual point below the loop items.
        // For simplicity, we'll draw from bottom of loopHeader for now, then curve/segment.
        { from: 'loopHeader', to: 'compile2D', type: 'flow', fromSide: 'bottom', toSide: 'top', pathType: 'segmented', segments: [{y:'+=280'}, {x:'target', y:'targetFirstHalf'}, {x:'target'}] }, // Custom path routing
        { from: 'loopHeader', to: 'compile3D', type: 'flow', fromSide: 'bottom', toSide: 'top', pathType: 'segmented', segments: [{y:'+=280'}, {x:'target', y:'targetFirstHalf'}, {x:'target'}] },

        { from: 'compile2D', to: 'endAnimFlow', type: 'flow', fromSide: 'bottom', toSide: 'top', toOffset:0.3},
        { from: 'compile3D', to: 'endAnimFlow', type: 'flow', fromSide: 'bottom', toSide: 'top', toOffset:0.7}
    ];

    initialArrowDefs.forEach(def => {
        const id = `arrow-${nextArrowId++}`;
        createArrowElement(id, def.from, def.to, def.type, def.fromSide, def.toSide, def.fromOffset, def.toOffset, def.pathType, def.segments);
    });

    function updateArrowPath(arrowId) {
        const arrow = arrows[arrowId];
        if (!arrow || !components[arrow.fromId] || !components[arrow.toId]) return;
        const fromComp = components[arrow.fromId];
        const toComp = components[arrow.toId];

        const startPoint = getPortCoordinates(fromComp, arrow.fromSide, arrow.fromOffset);
        const endPoint = getPortCoordinates(toComp, arrow.toSide, arrow.toOffset);
        
        let d;
        if (arrow.pathType === 'segmented' && arrow.segments) {
            let currentX = startPoint.x;
            let currentY = startPoint.y;
            d = `M ${currentX} ${currentY}`;
            arrow.segments.forEach(seg => {
                if (seg.x !== undefined && seg.y !== undefined) { // Absolute point
                    currentX = seg.x; currentY = seg.y;
                } else if (seg.x !== undefined) { // Horizontal line to new x
                    if (seg.x === 'target') currentX = endPoint.x; else currentX = seg.x;
                } else if (seg.y !== undefined) { // Vertical line to new y
                    if (seg.y === 'target') currentY = endPoint.y; 
                    else if (typeof seg.y === 'string' && seg.y.includes('targetFirstHalf')) currentY = (startPoint.y + endPoint.y)/2;
                    else currentY = seg.y;
                }
                // Relative movement:
                if (typeof seg.x === 'string' && seg.x.startsWith('+=')) currentX += parseFloat(seg.x.substring(2));
                if (typeof seg.y === 'string' && seg.y.startsWith('+=')) currentY += parseFloat(seg.y.substring(2));
                
                d += ` L ${currentX} ${currentY}`;
            });
            if(currentX !== endPoint.x || currentY !== endPoint.y) d += ` L ${endPoint.x} ${endPoint.y}`; // Ensure final connection
        } else {
             // Default right-angle connector for vertical flow
            const midY = startPoint.y + (endPoint.y - startPoint.y) / 2; // Bend halfway
            if (Math.abs(startPoint.x - endPoint.x) < 10 && endPoint.y > startPoint.y) { // Mostly vertical down
                d = `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`;
            } else { // Default elbow
                d = `M ${startPoint.x} ${startPoint.y} V ${midY} H ${endPoint.x} V ${endPoint.y}`;
            }
        }
        arrow.el.setAttribute('d', d);
    }

    function createArrowElement(id, fromId, toId, type, fromSide='bottom', toSide='top', fromOffset=0.5, toOffset=0.5, pathType, segments) {
        if (!components[fromId] || !components[toId]) { console.warn(`Missing component for arrow: ${fromId} or ${toId}`); return; }
        const path = document.createElementNS(ns, 'path');
        path.setAttribute('id', id);
        path.classList.add('arrow-path', `${type}-arrow`);
        path.setAttribute('marker-end', `url(#arrowhead-${type})`);
        arrowPathsContainer.appendChild(path);
        arrows[id] = { el: path, fromId, toId, type, fromSide, toSide, fromOffset, toOffset, pathType, segments };
        components[fromId].connections.push(id);
        components[toId].connections.push(id);
        updateArrowPath(id);
        path.addEventListener('click', (e) => { e.stopPropagation(); selectElement(path, 'arrow'); });
    }

    function onComponentMouseDown(e) { /* ... same dragging setup ... */ 
        if (e.button !== 0) return;
        activeDrag = e.currentTarget;
        activeDrag.classList.add('selected'); 
        dragOffsetX = e.clientX - activeDrag.offsetLeft;
        dragOffsetY = e.clientY - activeDrag.offsetTop;
        document.addEventListener('mousemove', onDrag);
        document.addEventListener('mouseup', onDragEnd);
        selectElement(activeDrag, 'component');
    }
    function onDrag(e) { /* ... same dragging logic ... */
        if (!activeDrag) return;
        e.preventDefault();
        let newX = e.clientX - dragOffsetX;
        let newY = e.clientY - dragOffsetY;
        newX = Math.max(0, Math.min(newX, diagramContainer.offsetWidth - activeDrag.offsetWidth));
        newY = Math.max(0, Math.min(newY, diagramContainer.offsetHeight - activeDrag.offsetHeight));
        activeDrag.style.left = newX + 'px';
        activeDrag.style.top = newY + 'px';
        const compData = components[activeDrag.id];
        compData.x = newX;
        compData.y = newY;
        compData.connections.forEach(arrowId => updateArrowPath(arrowId));
     }
    function onDragEnd() { /* ... same ... */ 
        if (!activeDrag) return;
        activeDrag = null;
        document.removeEventListener('mousemove', onDrag);
        document.removeEventListener('mouseup', onDragEnd);
    }
    function selectElement(element, type) { /* ... same selection logic ... */
        if (selectedElement) {
            selectedElement.classList.remove('selected');
             if (selectedElementType === 'arrow' && arrows[selectedElement.id]) {
                const arrowData = arrows[selectedElement.id];
                arrowData.el.setAttribute('marker-end', `url(#arrowhead-${arrowData.type})`);
            }
        }
        selectedElement = element;
        selectedElementType = type;
        if (selectedElement) {
            selectedElement.classList.add('selected');
            if (type === 'arrow' && arrows[element.id]) { 
                 const arrowData = arrows[element.id];
                arrowData.el.setAttribute('marker-end', `url(#arrowhead-${arrowData.type}-selected)`);
            }
        }
     }
    diagramContainer.addEventListener('click', (e) => { /* ... same ... */ 
         if (e.target === diagramContainer) selectElement(null, null);
    });
    console.log("Interactive animation flowchart initialized.");
});
</script>
</body>
</html>